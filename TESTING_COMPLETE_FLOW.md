# 完整 AI 降噪流程测试说明

## 🎯 测试目标

你要求测试的是 **整个 AI 降噪识别的流程**，而不是单独测试 AI 调用。

这意味着要测试从异常抛出到最终生成工单的 **完整生命周期**。

---

## 📊 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│  1. Exception Thrown (异常抛出)                                  │
│     - NullPointerException, SQLException, TimeoutException...   │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  2. Capture Layer (捕获层)                                       │
│     ├─ ExceptionCaptureFilter (Servlet Filter)                  │
│     ├─ GlobalExceptionHandler (@ControllerAdvice)               │
│     └─ ExceptionCaptureAspect (AOP)                             │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  3. ExceptionCollector (异常收集器)                              │
│     - 统一入口                                                   │
│     - 构建 ExceptionInfo                                        │
│     - 生成 Fingerprint (MD5指纹)                                │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  4. Layer 0: Ignore List Filter (基础过滤)                      │
│     ✅ 通过条件:                                                 │
│        - 不在忽略的异常类型列表                                   │
│        - 不在忽略的包前缀列表                                     │
│        - 不包含忽略的消息关键词                                   │
│        - 不是忽略的 HTTP 状态码                                  │
│     ❌ 被过滤: 健康检查、心跳、Actuator 等                        │
│     📊 过滤率: ~10%                                              │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  5. Layer 1: Fingerprint Deduplication (指纹去重)               │
│     ✅ 通过条件: 时间窗口内首次出现（fingerprint 不在缓存）       │
│     ❌ 被过滤: 2分钟内相同指纹的重复异常                          │
│     📊 过滤率: ~50-60%                                           │
│     ⚡ 性能: < 1ms (内存缓存 Caffeine)                           │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  6. Layer 1.5: Rule Engine (规则引擎)                           │
│     ✅ 通过条件:                                                 │
│        - 频率未超限（5分钟内 < 10次）                            │
│        - 不在静默时间窗口（凌晨2-6点仅允许P0）                    │
│        - 环境策略允许（测试环境不报P3/P4）                        │
│     ❌ 被过滤: 异常风暴、非工作时间低优先级                       │
│     📊 过滤率: ~10-20%                                           │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  7. Layer 2: AI Intelligent Denoise (AI 智能降噪) ⭐             │
│     📥 输入:                                                     │
│        - 当前异常信息 (ExceptionInfo)                            │
│        - 历史异常记录 (从 app_alarm_record 查询最近2分钟)         │
│     🤖 AI 处理:                                                 │
│        1. 查询数据库获取历史异常                                  │
│        2. 构建 Prompt (当前异常 + 历史上下文)                     │
│        3. 调用 LangChain4J → OpenAI-compatible API              │
│        4. LLM 分析并返回 JSON 决策                               │
│     📤 输出: DenoiseDecision                                     │
│        {                                                        │
│          "shouldAlert": true/false,    // 是否需要报警          │
│          "isDuplicate": true/false,    // 是否重复              │
│          "similarityScore": 0.0-1.0,   // 相似度                │
│          "suggestedSeverity": "P0-P4", // 建议严重级别          │
│          "reason": "...",              // 判断原因                │
│          "suggestion": "..."           // 处理建议                │
│        }                                                        │
│     ✅ 通过条件: shouldAlert = true                              │
│     ❌ 被过滤: shouldAlert = false (AI判断为重复/不重要)          │
│     📊 过滤率: ~20-30%                                           │
│     💾 缓存: Caffeine (5分钟TTL, 10000容量)                      │
│     ⚡ 性能:                                                     │
│        - 首次调用: 1-3秒 (LLM处理时间)                           │
│        - 缓存命中: < 50ms                                        │
│     💰 成本: ~¥0.001/次 (DeepSeek-V3)                           │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  8. ExceptionPersistenceService (异常持久化)                     │
│     - 将异常信息写入 app_alarm_record 表                         │
│     - 包含 AI 的判断结果 (ai_processed, ai_similarity_score)    │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  9. TicketGenerationService (工单生成)                          │
│     - 检查是否存在相同 fingerprint 的 OPEN 工单                  │
│     - 如果存在: 更新 occurrence_count (+1)                       │
│     - 如果不存在: 创建新工单到 app_alarm_ticket 表               │
│     - 设置 severity (优先使用 AI 建议的级别)                     │
│     - 计算 SLA deadline                                         │
└─────────────────────┬───────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────────┐
│  10. 最终结果                                                    │
│      ✅ 数据库中有告警记录 (app_alarm_record)                     │
│      ✅ 数据库中有工单 (app_alarm_ticket)                        │
│      ✅ 工单状态: PENDING → ASSIGNED → IN_PROGRESS → RESOLVED   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🧪 测试类: FullPipelineIntegrationTest

### 为什么创建这个测试类？

之前的测试类（`AiDenoiseWithDataTest`, `AiDenoiseQuickTest`）只测试了 **AI 层**，没有测试完整流程。

**FullPipelineIntegrationTest** 的特点：

1. ✅ **真实异常流转**: 使用 `ExceptionCollector.collect(exception)` 提交异常
2. ✅ **经过所有层**: Layer 0 → Layer 1 → Layer 1.5 → Layer 2 AI → Persistence → Ticket
3. ✅ **验证每一层**: 检查每一层的统计数据 (过滤率、缓存命中率)
4. ✅ **数据库验证**: 确认异常记录和工单被正确写入
5. ✅ **自动清理**: 测试完成后自动删除测试数据

---

## 📋 测试场景说明

### 场景1: 首次异常 - 完整流程 ✅

**测试目标**: 验证全新异常能成功通过所有层并生成工单

**测试步骤**:
1. 创建 `NullPointerException` 异常
2. 提交给 `ExceptionCollector`
3. 等待异步处理完成 (2秒)
4. 验证各层统计数据
5. 查询数据库确认记录和工单

**预期结果**:
```
Layer 0: 通过 (不在忽略列表)
Layer 1: 通过 (首次出现)
Layer 1.5: 通过 (不违反规则)
Layer 2 AI: 通过 (无历史记录，建议报警)
持久化: ✅ 1条记录写入 app_alarm_record
工单生成: ✅ 1个工单写入 app_alarm_ticket (状态: PENDING, 严重级别: P2)
```

---

### 场景2: 重复异常 - AI识别去重 ❌

**测试目标**: 验证重复异常被正确过滤

**测试步骤**:
1. 提交与场景1完全相同的异常
2. 查询处理前后的记录数

**预期结果**:
```
Layer 1: 被拦截 (指纹重复，在2分钟缓存窗口内)
  或
Layer 2 AI: 被拦截 (AI识别为重复，缓存命中)

持久化: ❌ 不应该生成新记录
工单: ❌ 不应该生成新工单
```

**关键指标**:
- 处理耗时: < 50ms (应该很快，被缓存拦截)
- Layer 1 去重过滤 +1
- 数据库记录数不变

---

### 场景3: 频繁异常 - 规则引擎 ⚡

**测试目标**: 验证规则引擎能检测异常风暴

**测试步骤**:
1. 连续提交 5 个相似但不完全相同的 `TimeoutException`
2. 每个异常的行号略有不同 (200, 201, 202, 203, 204)
3. 间隔 500ms

**预期结果**:
```
Layer 1: 通过 (fingerprint 不同，不会被去重)
Layer 1.5: 部分被拦截 (规则引擎检测到频率异常)
Layer 2 AI: 给出合并告警建议

持久化: 部分记录被写入
AI 建议: "检测到频繁超时异常，建议汇总处理，避免告警风暴"
```

**验证点**:
- 规则引擎过滤数 > 0
- AI 的 `suggestion` 字段包含合并建议

---

### 场景4: 综合统计 📊

**测试目标**: 展示所有层的性能指标和成本分析

**输出内容**:
```
Layer 0: 总检查、已过滤、过滤率
Layer 1: 总检查、去重过滤、过滤率、缓存大小、缓存驱逐
Layer 1.5: 总检查、规则过滤、过滤率
Layer 2 AI:
  - 总检查、AI实际调用、缓存命中、AI过滤
  - 缓存命中率、AI过滤率、缓存大小
  - 💰 成本分析:
    - API调用成本 = AI调用次数 × ¥0.001
    - 缓存节省成本 = 缓存命中次数 × ¥0.001
    - 总节省率 = 缓存命中率
持久化: 告警记录总数、工单总数
```

**理想指标**:
- Layer 0 过滤率: 5-10%
- Layer 1 过滤率: 50-60%
- Layer 1.5 过滤率: 10-20%
- Layer 2 AI 过滤率: 20-30%
- **整体过滤率**: 70-80% (只有20-30%需要人工处理)
- AI 缓存命中率: > 80%
- 单个异常成本: < ¥0.001

---

## 🚀 如何运行

### 快速开始 (运行场景1)

```bash
# Windows
.\mvnw.cmd test -Dtest=FullPipelineIntegrationTest#testScenario1_FirstException_FullPipeline

# Linux/Mac
./mvnw test -Dtest=FullPipelineIntegrationTest#testScenario1_FirstException_FullPipeline
```

### 运行所有场景

```bash
# Windows
.\mvnw.cmd test -Dtest=FullPipelineIntegrationTest

# Linux/Mac
./mvnw test -Dtest=FullPipelineIntegrationTest
```

---

## 📊 测试输出示例

### 成功输出

```
====================================================================================================
🚀 开始集成测试 - 完整AI降噪管道
====================================================================================================

📋 测试场景 1: 首次异常 - 完整降噪管道
--------------------------------------------------------------------------------
📤 步骤1: 将异常提交给 ExceptionCollector
   异常类型: java.lang.NullPointerException
   异常消息: Cannot invoke "com.example.User.getName()" because "user" is null
   错误位置: com.example.UserService.getUserInfo:100
⏱️  处理耗时: 1523ms

✅ Layer 0 验证: 基础过滤
   总检查: 1, 已过滤: 0, 过滤率: 0.0%

✅ Layer 1 验证: 指纹去重
   总检查: 1, 去重: 0, 缓存大小: 1

✅ Layer 1.5 验证: 规则引擎
   总检查: 1, 规则过滤: 0, 过滤率: 0.0%

✅ Layer 2 验证: AI 智能降噪
   总检查: 1, AI调用: 1, 缓存命中: 0, 已过滤: 0
   缓存命中率: 0.0%, AI过滤率: 0.0%

✅ 持久化验证: 检查数据库记录
   查询到告警记录数: 1
   记录ID: 12345
   异常指纹: a1b2c3d4e5f6...
   错误位置: com.example.UserService:getUserInfo:100
   AI处理: 是
   AI决策: ALERT
   AI原因: 首次出现的空指针异常，建议检查 user 对象的初始化逻辑

✅ 工单验证: 检查自动生成的工单
   查询到工单数: 1
   工单ID: 101
   工单标题: [P2][NullPointerException] Cannot invoke "User.getName()"
   严重级别: P2
   工单状态: PENDING
   发生次数: 1
   预期解决时间: 2025-11-16 13:30:00

================================================================================
✅ 场景1测试完成: 首次异常成功通过完整管道并生成工单
================================================================================

[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO] BUILD SUCCESS
```

---

## 🆚 与其他测试类的对比

| 测试类 | 测试范围 | 测试路径 | 写入数据库 | 适用场景 |
|--------|---------|---------|-----------|---------|
| **FullPipelineIntegrationTest** ⭐ | 完整管道 | Collector → Layer0/1/1.5/2 → Persist → Ticket | ✅ 是 | **测试完整流程** |
| AiDenoiseWithDataTest | 仅 AI 层 | 直接调用 `aiDenoiseService.shouldAlert()` | ✅ 是 (预先写入历史) | 评估 AI 准确性 |
| AiDenoiseQuickTest | 仅 AI 层 | 直接调用 `aiDenoiseService.shouldAlert()` | ❌ 否 | 快速验证 AI |
| FunnelDenoiseTest | Layer 0/1/1.5 | 单独测试各层 | ❌ 否 | 单元测试 |

**总结**:
- 你要测试 **整个流程** → 使用 **FullPipelineIntegrationTest** ✅
- 你要评估 **AI 模型效果** → 使用 **AiDenoiseWithDataTest**
- 你要快速验证 **AI 服务** → 使用 **AiDenoiseQuickTest**
- 你要单独测试 **某一层** → 使用 **FunnelDenoiseTest**

---

## 💡 关键理解

### 为什么要测试完整流程？

因为 One Agent 4J 采用 **多层漏斗设计**，每一层都可能过滤异常：

1. **Layer 0** 过滤 10% (忽略列表)
2. **Layer 1** 过滤 50-60% (指纹去重)
3. **Layer 1.5** 过滤 10-20% (规则引擎)
4. **Layer 2 AI** 过滤 20-30% (智能判断)

**最终**: 只有 **20-30%** 的异常真正需要生成工单

如果只测试 AI 层，你看不到:
- ❌ 重复异常是否被 Layer 1 提前拦截（避免浪费 AI 调用）
- ❌ 频繁异常是否被规则引擎过滤（避免告警风暴）
- ❌ 过滤后的异常是否正确写入数据库
- ❌ 工单是否正确生成和去重

**FullPipelineIntegrationTest** 解决了这些问题！

---

## 📈 成功标准

运行完整测试后，如果满足以下条件，说明系统正常工作：

```
✅ 所有4个场景测试通过 (Tests run: 4, Failures: 0, Errors: 0)
✅ Layer 1 过滤率 > 50% (指纹去重生效)
✅ Layer 2 AI 缓存命中率 > 30% (缓存生效)
✅ 场景1 生成了告警记录和工单
✅ 场景2 没有生成新记录 (重复被过滤)
✅ 场景3 规则引擎检测到频繁异常
✅ 场景4 成本在预期范围内 (< ¥0.01)
```

---

## 📚 相关文档

- **INTEGRATION_TEST_GUIDE.md**: 完整的集成测试使用指南
- **AI_MODEL_TEST_GUIDE.md**: AI 模型单独测试指南
- **CLAUDE.md**: 项目架构说明
- **DENOISE_STRATEGY.md**: 降噪策略文档

---

**现在你可以运行测试，查看整个 AI 降噪管道的完整流程！** 🚀
